{"version":3,"sources":["/Users/syafiqbasri/Development/POC/POC0015/fama-hotspot/web/node_modules/angular-ng-autocomplete/fesm5/angular-ng-autocomplete.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;;;;;;;;;MAUM,AAMA;;;;;;;;;;;;;;;gDAEmE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4sCnE,AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwMA;;;;;;;;gDAKA;;;;;;;;;;;KAWD;;;;;;;;;;;;;;;;;;;;;;gDAUC","file":"angular-ng-autocomplete.js","sourcesContent":["import { Component, EventEmitter, forwardRef, ViewEncapsulation, ElementRef, Renderer2, ViewChild, Input, Output, ContentChild, TemplateRef, Pipe, NgModule } from '@angular/core';\nimport { __spread, __assign } from 'tslib';\nimport { fromEvent } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AutocompleteLibComponent = /** @class */ (function () {\n    function AutocompleteLibComponent() {\n    }\n    /**\n     * @return {?}\n     */\n    AutocompleteLibComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n    };\n    AutocompleteLibComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'ng-autocomplete-lib',\n                    template: \"\\n    <p>\\n      autocomplete-lib works!\\n    </p>\\n  \"\n                }] }\n    ];\n    /** @nocollapse */\n    AutocompleteLibComponent.ctorParameters = function () { return []; };\n    return AutocompleteLibComponent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/autocomplete.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Keyboard events\n * @type {?}\n */\nvar isArrowUp = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 38; });\nvar ɵ0 = isArrowUp;\n/** @type {?} */\nvar isArrowDown = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 40; });\nvar ɵ1 = isArrowDown;\n/** @type {?} */\nvar isArrowUpDown = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return isArrowUp(keyCode) || isArrowDown(keyCode); });\nvar ɵ2 = isArrowUpDown;\n/** @type {?} */\nvar isEnter = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 13; });\nvar ɵ3 = isEnter;\n/** @type {?} */\nvar isBackspace = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 8; });\nvar ɵ4 = isBackspace;\n/** @type {?} */\nvar isDelete = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 46; });\nvar ɵ5 = isDelete;\n/** @type {?} */\nvar isESC = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 27; });\nvar ɵ6 = isESC;\n/** @type {?} */\nvar isTab = (/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction (keyCode) { return keyCode === 9; });\nvar ɵ7 = isTab;\nvar AutocompleteComponent = /** @class */ (function () {\n    function AutocompleteComponent(elementRef, renderer) {\n        this.renderer = renderer;\n        // input events\n        this.query = ''; // search query\n        // search query\n        this.filteredList = []; // list of items\n        // list of items\n        this.historyList = []; // list of history items\n        // list of history items\n        this.isHistoryListVisible = true;\n        this.selectedIdx = -1;\n        this.toHighlight = '';\n        this.notFound = false;\n        this.isFocused = false;\n        this.isOpen = false;\n        this.isScrollToEnd = false;\n        this.overlay = false;\n        this.manualOpen = undefined;\n        this.manualClose = undefined;\n        // @Inputs\n        /**\n         * Data of items list.\n         * It can be array of strings or array of objects.\n         */\n        this.data = [];\n        // keyword to filter the list\n        this.placeHolder = ''; // input placeholder\n        // input placeholder\n        this.heading = '';\n        /**\n         * Heading text of history list.\n         * If it is null then history heading is hidden.\n         */\n        this.historyHeading = 'Recently selected';\n        this.historyListMaxNumber = 15; // maximum number of items in the history list.\n        // maximum number of items in the history list.\n        this.notFoundText = 'Not found'; // set custom text when filter returns empty result\n        // input disable/enable\n        /**\n         * The minimum number of characters the user must type before a search is performed.\n         */\n        this.minQueryLength = 1;\n        // @Output events\n        /**\n         * Event that is emitted whenever an item from the list is selected.\n         */\n        this.selected = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is changed.\n         */\n        this.inputChanged = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is focused.\n         */\n        this.inputFocused = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is cleared.\n         */\n        this.inputCleared = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is opened.\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event that is emitted when scrolled to the end of items.\n         */\n        this.scrolledToEnd = new EventEmitter();\n        /**\n         * Propagates new value when model changes\n         */\n        this.propagateChange = (/**\n         * @return {?}\n         */\n        function () {\n        });\n        this.elementRef = elementRef;\n    }\n    /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     */\n    /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     * @param {?} value\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.writeValue = /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        this.query = value;\n    };\n    /**\n     * Registers a handler that is called when something in the view has changed\n     */\n    /**\n     * Registers a handler that is called when something in the view has changed\n     * @param {?} fn\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.registerOnChange = /**\n     * Registers a handler that is called when something in the view has changed\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this.propagateChange = fn;\n    };\n    /**\n     * Registers a handler specifically for when a control receives a touch event\n     */\n    /**\n     * Registers a handler specifically for when a control receives a touch event\n     * @param {?} fn\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.registerOnTouched = /**\n     * Registers a handler specifically for when a control receives a touch event\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n    };\n    /**\n     * Event that is called when the value of an input element is changed\n     */\n    /**\n     * Event that is called when the value of an input element is changed\n     * @param {?} event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onChange = /**\n     * Event that is called when the value of an input element is changed\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this.propagateChange(event.target.value);\n    };\n    /**\n     * Event that is called when the control status changes to or from DISABLED\n     */\n    /**\n     * Event that is called when the control status changes to or from DISABLED\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.setDisabledState = /**\n     * Event that is called when the control status changes to or from DISABLED\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.setInitialValue(this.initialValue);\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        this.initEventStream();\n        this.handleScroll();\n    };\n    /**\n     * Set initial value\n     * @param value\n     */\n    /**\n     * Set initial value\n     * @param {?} value\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.setInitialValue = /**\n     * Set initial value\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        if (this.initialValue) {\n            this.select(value);\n        }\n    };\n    /**\n     * Update search results\n     */\n    /**\n     * Update search results\n     * @param {?} changes\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.ngOnChanges = /**\n     * Update search results\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes &&\n            changes.data &&\n            Array.isArray(changes.data.currentValue)) {\n            this.handleItemsChange();\n            if (!changes.data.firstChange && this.isFocused) {\n                this.handleOpen();\n            }\n        }\n    };\n    /**\n     * Items change\n     */\n    /**\n     * Items change\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleItemsChange = /**\n     * Items change\n     * @return {?}\n     */\n    function () {\n        this.isScrollToEnd = false;\n        if (!this.isOpen) {\n            return;\n        }\n        this.filteredList = this.data;\n        this.notFound = !this.filteredList || this.filteredList.length === 0;\n    };\n    /**\n     * Filter data\n     */\n    /**\n     * Filter data\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.filterList = /**\n     * Filter data\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.selectedIdx = -1;\n        this.initSearchHistory();\n        if (this.query != null && this.data) {\n            this.toHighlight = this.query;\n            this.filteredList = this.data.filter((/**\n             * @param {?} item\n             * @return {?}\n             */\n            function (item) {\n                if (typeof item === 'string') {\n                    // string logic, check equality of strings\n                    return item.toLowerCase().indexOf(_this.query.toLowerCase()) > -1;\n                }\n                else if (typeof item === 'object' && item.constructor === Object) {\n                    // object logic, check property equality\n                    return item[_this.searchKeyword].toLowerCase().indexOf(_this.query.toLowerCase()) > -1;\n                }\n            }));\n        }\n        else {\n            this.notFound = false;\n        }\n    };\n    /**\n     * Check type of item in the list.\n     * @param item\n     */\n    /**\n     * Check type of item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.isType = /**\n     * Check type of item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        return typeof item === 'string';\n    };\n    /**\n     * Select item in the list.\n     * @param item\n     */\n    /**\n     * Select item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.select = /**\n     * Select item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        var _this = this;\n        this.query = !this.isType(item) ? item[this.searchKeyword] : item;\n        this.isOpen = true;\n        this.overlay = false;\n        this.selected.emit(item);\n        this.propagateChange(item);\n        if (this.initialValue) {\n            // check if history already exists in localStorage and then update\n            /** @type {?} */\n            var history_1 = window.localStorage.getItem(\"\" + this.historyIdentifier);\n            if (history_1) {\n                /** @type {?} */\n                var existingHistory = JSON.parse(localStorage[\"\" + this.historyIdentifier]);\n                if (!(existingHistory instanceof Array))\n                    existingHistory = [];\n                // check if selected item exists in existingHistory\n                if (!existingHistory.some((/**\n                 * @param {?} existingItem\n                 * @return {?}\n                 */\n                function (existingItem) { return !_this.isType(existingItem)\n                    ? existingItem[_this.searchKeyword] == item[_this.searchKeyword] : existingItem == item; }))) {\n                    existingHistory.unshift(item);\n                    localStorage.setItem(\"\" + this.historyIdentifier, JSON.stringify(existingHistory));\n                    // check if items don't exceed max allowed number\n                    if (existingHistory.length >= this.historyListMaxNumber) {\n                        existingHistory.splice(existingHistory.length - 1, 1);\n                        localStorage.setItem(\"\" + this.historyIdentifier, JSON.stringify(existingHistory));\n                    }\n                }\n                else {\n                    // if selected item exists in existingHistory swap to top in array\n                    if (!this.isType(item)) {\n                        // object logic\n                        /** @type {?} */\n                        var copiedExistingHistory = existingHistory.slice();\n                        // copy original existingHistory array\n                        /** @type {?} */\n                        var selectedIndex = copiedExistingHistory.map((/**\n                         * @param {?} el\n                         * @return {?}\n                         */\n                        function (el) { return el[_this.searchKeyword]; })).indexOf(item[this.searchKeyword]);\n                        copiedExistingHistory.splice(selectedIndex, 1);\n                        copiedExistingHistory.splice(0, 0, item);\n                        localStorage.setItem(\"\" + this.historyIdentifier, JSON.stringify(copiedExistingHistory));\n                    }\n                    else {\n                        // string logic\n                        /** @type {?} */\n                        var copiedExistingHistory = existingHistory.slice();\n                        copiedExistingHistory.splice(copiedExistingHistory.indexOf(item), 1);\n                        copiedExistingHistory.splice(0, 0, item);\n                        localStorage.setItem(\"\" + this.historyIdentifier, JSON.stringify(copiedExistingHistory));\n                    }\n                }\n            }\n            else {\n                this.saveHistory(item);\n            }\n        }\n        else {\n            this.saveHistory(item);\n        }\n        this.handleClose();\n    };\n    /**\n     * Document click\n     * @param e event\n     */\n    /**\n     * Document click\n     * @param {?} e event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleClick = /**\n     * Document click\n     * @param {?} e event\n     * @return {?}\n     */\n    function (e) {\n        /** @type {?} */\n        var clickedComponent = e.target;\n        /** @type {?} */\n        var inside = false;\n        do {\n            if (clickedComponent === this.elementRef.nativeElement) {\n                inside = true;\n                if (this.filteredList.length) {\n                    this.handleOpen();\n                }\n            }\n            clickedComponent = clickedComponent.parentNode;\n        } while (clickedComponent);\n        if (!inside) {\n            this.handleClose();\n        }\n    };\n    /**\n     * Handle body overlay\n     */\n    /**\n     * Handle body overlay\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleOverlay = /**\n     * Handle body overlay\n     * @return {?}\n     */\n    function () {\n        this.overlay = false;\n    };\n    /**\n     * Scroll items\n     */\n    /**\n     * Scroll items\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleScroll = /**\n     * Scroll items\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.renderer.listen(this.filteredListElement.nativeElement, 'scroll', (/**\n         * @return {?}\n         */\n        function () {\n            _this.scrollToEnd();\n        }));\n    };\n    /**\n     * Define panel state\n     */\n    /**\n     * Define panel state\n     * @param {?} event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.setPanelState = /**\n     * Define panel state\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (event) {\n            event.stopPropagation();\n        }\n        // If controls are untouched\n        if (typeof this.manualOpen === 'undefined'\n            && typeof this.manualClose === 'undefined') {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // If one of the controls is untouched and other is deactivated\n        if (typeof this.manualOpen === 'undefined'\n            && this.manualClose === false\n            || typeof this.manualClose === 'undefined'\n                && this.manualOpen === false) {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // if controls are touched but both are deactivated\n        if (this.manualOpen === false && this.manualClose === false) {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // if open control is touched and activated\n        if (this.manualOpen) {\n            this.isOpen = false;\n            this.handleOpen();\n            this.manualOpen = false;\n        }\n        // if close control is touched and activated\n        if (this.manualClose) {\n            this.isOpen = true;\n            this.handleClose();\n            this.manualClose = false;\n        }\n    };\n    /**\n     * Manual controls\n     */\n    /**\n     * Manual controls\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.open = /**\n     * Manual controls\n     * @return {?}\n     */\n    function () {\n        this.manualOpen = true;\n        this.isOpen = false;\n        this.handleOpen();\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.close = /**\n     * @return {?}\n     */\n    function () {\n        this.manualClose = true;\n        this.isOpen = true;\n        this.handleClose();\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.focus = /**\n     * @return {?}\n     */\n    function () {\n        this.handleFocus(event);\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.clear = /**\n     * @return {?}\n     */\n    function () {\n        this.remove(event);\n    };\n    /**\n     * Remove search query\n     */\n    /**\n     * Remove search query\n     * @param {?} e\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.remove = /**\n     * Remove search query\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        e.stopPropagation();\n        this.query = '';\n        this.inputCleared.emit();\n        this.propagateChange(this.query);\n        this.setPanelState(e);\n    };\n    /**\n     * Initialize historyList search\n     */\n    /**\n     * Initialize historyList search\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.initSearchHistory = /**\n     * Initialize historyList search\n     * @return {?}\n     */\n    function () {\n        this.isHistoryListVisible = false;\n        if (this.historyIdentifier && !this.query) {\n            /** @type {?} */\n            var history_2 = window.localStorage.getItem(\"\" + this.historyIdentifier);\n            if (history_2) {\n                this.isHistoryListVisible = true;\n                this.filteredList = [];\n                this.historyList = history_2 ? JSON.parse(history_2) : [];\n            }\n            else {\n                this.isHistoryListVisible = false;\n            }\n        }\n        else {\n            this.isHistoryListVisible = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleOpen = /**\n     * @return {?}\n     */\n    function () {\n        if (this.isOpen || this.isOpen && !this.isLoading) {\n            return;\n        }\n        // If data exists\n        if (this.data && this.data.length) {\n            this.isOpen = true;\n            this.overlay = true;\n            this.filterList();\n            this.opened.emit();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleClose = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.isOpen) {\n            this.isFocused = false;\n            return;\n        }\n        this.isOpen = false;\n        this.overlay = false;\n        this.filteredList = [];\n        this.selectedIdx = -1;\n        this.notFound = false;\n        this.isHistoryListVisible = false;\n        this.isFocused = false;\n        this.closed.emit();\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.handleFocus = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        this.searchInput.nativeElement.focus();\n        if (this.isFocused) {\n            return;\n        }\n        this.inputFocused.emit(e);\n        // if data exists then open\n        if (this.data && this.data.length) {\n            this.setPanelState(event);\n        }\n        this.isFocused = true;\n    };\n    /**\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.scrollToEnd = /**\n     * @return {?}\n     */\n    function () {\n        if (this.isScrollToEnd) {\n            return;\n        }\n        /** @type {?} */\n        var scrollTop = this.filteredListElement.nativeElement\n            .scrollTop;\n        /** @type {?} */\n        var scrollHeight = this.filteredListElement.nativeElement\n            .scrollHeight;\n        /** @type {?} */\n        var elementHeight = this.filteredListElement.nativeElement\n            .clientHeight;\n        /** @type {?} */\n        var atBottom = scrollHeight === scrollTop + elementHeight;\n        if (atBottom) {\n            this.scrolledToEnd.emit();\n            this.isScrollToEnd = true;\n        }\n    };\n    /**\n     * Initialize keyboard events\n     */\n    /**\n     * Initialize keyboard events\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.initEventStream = /**\n     * Initialize keyboard events\n     * @return {?}\n     */\n    function () {\n        this.inputKeyUp$ = fromEvent(this.searchInput.nativeElement, 'keyup').pipe(map((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return e; })));\n        this.inputKeyDown$ = fromEvent(this.searchInput.nativeElement, 'keydown').pipe(map((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return e; })));\n        this.listenEventStream();\n    };\n    /**\n     * Listen keyboard events\n     */\n    /**\n     * Listen keyboard events\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.listenEventStream = /**\n     * Listen keyboard events\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // key up event\n        this.inputKeyUp$\n            .pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            return !isArrowUpDown(e.keyCode) &&\n                !isEnter(e.keyCode) &&\n                !isESC(e.keyCode) &&\n                !isTab(e.keyCode);\n        })), debounceTime(this.debounceTime)).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            _this.onKeyUp(e);\n        }));\n        // cursor up & down\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isArrowUpDown(e.keyCode); }))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            e.preventDefault();\n            _this.onFocusItem(e);\n        }));\n        // enter keyup\n        this.inputKeyUp$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isEnter(e.keyCode); }))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            //this.onHandleEnter();\n        }));\n        // enter keydown\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isEnter(e.keyCode); }))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            _this.onHandleEnter();\n        }));\n        // ESC\n        this.inputKeyUp$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isESC(e.keyCode); }), debounceTime(100))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            _this.onEsc();\n        }));\n        // TAB\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isTab(e.keyCode); }))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            _this.onTab();\n        }));\n        // delete\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) { return isBackspace(e.keyCode) || isDelete(e.keyCode); }))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            _this.onDelete();\n        }));\n    };\n    /**\n     * on keyup == when input changed\n     * @param e event\n     */\n    /**\n     * on keyup == when input changed\n     * @param {?} e event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onKeyUp = /**\n     * on keyup == when input changed\n     * @param {?} e event\n     * @return {?}\n     */\n    function (e) {\n        this.notFound = false; // search results are unknown while typing\n        // if input is empty\n        if (!this.query) {\n            this.notFound = false;\n            this.inputChanged.emit(e.target.value);\n            this.inputCleared.emit();\n            //this.filterList();\n            this.setPanelState(e);\n        }\n        // note that '' can be a valid query\n        if (!this.query && this.query !== '') {\n            return;\n        }\n        // if query >= to minQueryLength\n        if (this.query.length >= this.minQueryLength) {\n            this.inputChanged.emit(e.target.value);\n            this.filterList();\n            // If no results found\n            if (!this.filteredList.length && !this.isLoading) {\n                this.notFoundText ? this.notFound = true : this.notFound = false;\n            }\n        }\n    };\n    /**\n     * Keyboard arrow top and arrow bottom\n     * @param e event\n     */\n    /**\n     * Keyboard arrow top and arrow bottom\n     * @param {?} e event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onFocusItem = /**\n     * Keyboard arrow top and arrow bottom\n     * @param {?} e event\n     * @return {?}\n     */\n    function (e) {\n        // move arrow up and down on filteredList or historyList\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n            // filteredList\n            /** @type {?} */\n            var totalNumItem = this.filteredList.length;\n            if (e.key === 'ArrowDown') {\n                /** @type {?} */\n                var sum = this.selectedIdx;\n                sum = (this.selectedIdx === null) ? 0 : sum + 1;\n                this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n            else if (e.key === 'ArrowUp') {\n                if (this.selectedIdx == -1) {\n                    this.selectedIdx = 0;\n                }\n                this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n        }\n        else {\n            // historyList\n            /** @type {?} */\n            var totalNumItem = this.historyList.length;\n            if (e.key === 'ArrowDown') {\n                /** @type {?} */\n                var sum = this.selectedIdx;\n                sum = (this.selectedIdx === null) ? 0 : sum + 1;\n                this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n            else if (e.key === 'ArrowUp') {\n                if (this.selectedIdx == -1) {\n                    this.selectedIdx = 0;\n                }\n                this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n        }\n    };\n    /**\n     * Scroll to focused item\n     * * @param index\n     */\n    /**\n     * Scroll to focused item\n     * * \\@param index\n     * @param {?} index\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.scrollToFocusedItem = /**\n     * Scroll to focused item\n     * * \\@param index\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        /** @type {?} */\n        var listElement = null;\n        // Define list element\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n            // filteredList element\n            listElement = this.filteredListElement.nativeElement;\n        }\n        else {\n            // historyList element\n            listElement = this.historyListElement.nativeElement;\n        }\n        /** @type {?} */\n        var items = Array.prototype.slice.call(listElement.childNodes).filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        function (node) {\n            if (node.nodeType === 1) {\n                // if node is element\n                return node.className.includes('item');\n            }\n            else {\n                return false;\n            }\n        }));\n        if (!items.length) {\n            return;\n        }\n        /** @type {?} */\n        var listHeight = listElement.offsetHeight;\n        /** @type {?} */\n        var itemHeight = items[index].offsetHeight;\n        /** @type {?} */\n        var visibleTop = listElement.scrollTop;\n        /** @type {?} */\n        var visibleBottom = listElement.scrollTop + listHeight - itemHeight;\n        /** @type {?} */\n        var targetPosition = items[index].offsetTop;\n        if (targetPosition < visibleTop) {\n            listElement.scrollTop = targetPosition;\n        }\n        if (targetPosition > visibleBottom) {\n            listElement.scrollTop = targetPosition - listHeight + itemHeight;\n        }\n    };\n    /**\n     * Select item on enter click\n     */\n    /**\n     * Select item on enter click\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onHandleEnter = /**\n     * Select item on enter click\n     * @return {?}\n     */\n    function () {\n        // click enter to choose item from filteredList or historyList\n        if (this.selectedIdx > -1) {\n            if (!this.historyList.length || !this.isHistoryListVisible) {\n                // filteredList\n                this.query = !this.isType(this.filteredList[this.selectedIdx])\n                    ? this.filteredList[this.selectedIdx][this.searchKeyword]\n                    : this.filteredList[this.selectedIdx];\n                this.saveHistory(this.filteredList[this.selectedIdx]);\n                this.select(this.filteredList[this.selectedIdx]);\n            }\n            else {\n                // historyList\n                this.query = !this.isType(this.historyList[this.selectedIdx])\n                    ? this.historyList[this.selectedIdx][this.searchKeyword]\n                    : this.historyList[this.selectedIdx];\n                this.saveHistory(this.historyList[this.selectedIdx]);\n                this.select(this.historyList[this.selectedIdx]);\n            }\n        }\n        this.isHistoryListVisible = false;\n        this.handleClose();\n    };\n    /**\n     * Esc click\n     */\n    /**\n     * Esc click\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onEsc = /**\n     * Esc click\n     * @return {?}\n     */\n    function () {\n        this.searchInput.nativeElement.blur();\n        this.handleClose();\n    };\n    /**\n     * Tab click\n     */\n    /**\n     * Tab click\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onTab = /**\n     * Tab click\n     * @return {?}\n     */\n    function () {\n        this.searchInput.nativeElement.blur();\n        this.handleClose();\n    };\n    /**\n     * Delete click\n     */\n    /**\n     * Delete click\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.onDelete = /**\n     * Delete click\n     * @return {?}\n     */\n    function () {\n        // panel is open on delete\n        this.isOpen = true;\n    };\n    /**\n     * Select item to save in localStorage\n     * @param selected\n     */\n    /**\n     * Select item to save in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.saveHistory = /**\n     * Select item to save in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    function (selected) {\n        var _this = this;\n        if (this.historyIdentifier) {\n            // check if selected item exists in historyList\n            if (!this.historyList.some((/**\n             * @param {?} item\n             * @return {?}\n             */\n            function (item) { return !_this.isType(item)\n                ? item[_this.searchKeyword] == selected[_this.searchKeyword] : item == selected; }))) {\n                this.saveHistoryToLocalStorage(__spread([selected], this.historyList));\n                // check if items don't exceed max allowed number\n                if (this.historyList.length >= this.historyListMaxNumber) {\n                    this.historyList.splice(this.historyList.length - 1, 1);\n                    this.saveHistoryToLocalStorage(__spread([selected], this.historyList));\n                }\n            }\n            else {\n                // if selected item exists in historyList swap to top in array\n                if (!this.isType(selected)) {\n                    // object logic\n                    /** @type {?} */\n                    var copiedHistoryList = this.historyList.slice();\n                    // copy original historyList array\n                    /** @type {?} */\n                    var selectedIndex = copiedHistoryList.map((/**\n                     * @param {?} item\n                     * @return {?}\n                     */\n                    function (item) { return item[_this.searchKeyword]; })).indexOf(selected[this.searchKeyword]);\n                    copiedHistoryList.splice(selectedIndex, 1);\n                    copiedHistoryList.splice(0, 0, selected);\n                    this.saveHistoryToLocalStorage(__spread(copiedHistoryList));\n                }\n                else {\n                    // string logic\n                    /** @type {?} */\n                    var copiedHistoryList = this.historyList.slice();\n                    copiedHistoryList.splice(this.historyList.indexOf(selected), 1);\n                    copiedHistoryList.splice(0, 0, selected);\n                    this.saveHistoryToLocalStorage(__spread(copiedHistoryList));\n                }\n            }\n        }\n    };\n    /**\n     * Save item in localStorage\n     * @param selected\n     */\n    /**\n     * Save item in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.saveHistoryToLocalStorage = /**\n     * Save item in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    function (selected) {\n        window.localStorage.setItem(\"\" + this.historyIdentifier, JSON.stringify(selected));\n    };\n    /**\n     * Remove item from localStorage\n     * @param index\n     * @param e event\n     */\n    /**\n     * Remove item from localStorage\n     * @param {?} index\n     * @param {?} e event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.removeHistoryItem = /**\n     * Remove item from localStorage\n     * @param {?} index\n     * @param {?} e event\n     * @return {?}\n     */\n    function (index, e) {\n        e.stopPropagation();\n        this.historyList = this.historyList.filter((/**\n         * @param {?} v\n         * @param {?} i\n         * @return {?}\n         */\n        function (v, i) { return i !== index; }));\n        this.saveHistoryToLocalStorage(this.historyList);\n        if (this.historyList.length == 0) {\n            window.localStorage.removeItem(\"\" + this.historyIdentifier);\n            this.filterList();\n        }\n    };\n    /**\n     * Reset localStorage\n     * @param e event\n     */\n    /**\n     * Reset localStorage\n     * @param {?} e event\n     * @return {?}\n     */\n    AutocompleteComponent.prototype.resetHistoryList = /**\n     * Reset localStorage\n     * @param {?} e event\n     * @return {?}\n     */\n    function (e) {\n        e.stopPropagation();\n        this.historyList = [];\n        window.localStorage.removeItem(\"\" + this.historyIdentifier);\n        this.filterList();\n    };\n    AutocompleteComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'ng-autocomplete',\n                    template: \"<div class=\\\"autocomplete-container\\\"\\n     [ngClass]=\\\"{ 'active': isOpen}\\\">\\n  <div class=\\\"input-container\\\">\\n    <input #searchInput type=\\\"text\\\" placeholder={{placeHolder}}\\n           [(ngModel)]=query\\n           (input)=\\\"onChange($event)\\\"\\n           (focus)=handleFocus($event)\\n           [disabled]=\\\"disabled\\\">\\n    <div class=\\\"x\\\" *ngIf=\\\"query && !isLoading && !disabled\\\" (click)=\\\"remove($event)\\\">\\n      <i class=\\\"material-icons\\\">close</i>\\n    </div>\\n    <!--Loading mask-->\\n    <div class=\\\"sk-fading-circle\\\" *ngIf=\\\"isLoading\\\">\\n      <div class=\\\"sk-circle1 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle2 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle3 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle4 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle5 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle6 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle7 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle8 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle9 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle10 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle11 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle12 sk-circle\\\"></div>\\n    </div>\\n  </div>\\n\\n  <!--FilteredList items-->\\n  <div class=\\\"suggestions-container\\\"\\n       [ngClass]=\\\"{ 'is-hidden': isHistoryListVisible, 'is-visible': !isHistoryListVisible}\\\">\\n    <!--FilteredList heading-->\\n    <div class=\\\"heading\\\" *ngIf=\\\"filteredList.length > 0 && heading\\\">\\n      <div class=\\\"text\\\">{{heading}}</div>\\n    </div>\\n\\n    <ul #filteredListElement>\\n      <li *ngFor=\\\"let item of filteredList; let idx = index\\\" class=\\\"item\\\">\\n        <!--string logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='isType(item)'\\n             (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate;  context: { $implicit: item | highlight: toHighlight }\\\">\\n          </ng-container>\\n        </div>\\n        <!--object logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='!isType(item)'\\n             (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item | highlight: toHighlight : searchKeyword }\\\">\\n          </ng-container>\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\\n  <!--HistoryList items-->\\n  <div class=\\\"suggestions-container\\\"\\n       [ngClass]=\\\"{ 'is-hidden': !isHistoryListVisible, 'is-visible': isHistoryListVisible}\\\">\\n    <!--HistoryList heading-->\\n    <div class=\\\"heading\\\" *ngIf=\\\"historyList.length > 0 && historyHeading\\\">\\n      <div class=\\\"text\\\">{{historyHeading}}</div>\\n      <div class=\\\"x\\\" (click)=\\\"resetHistoryList($event)\\\">\\n        <i class=\\\"material-icons\\\">delete</i>\\n      </div>\\n    </div>\\n\\n    <ul #historyListElement>\\n      <li *ngFor=\\\"let item of historyList; let idx = index\\\" class=\\\"item\\\">\\n        <!--string logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='isType(item)' (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate;  context: { $implicit: item }\\\">\\n          </ng-container>\\n        </div>\\n        <!--object logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='!isType(item)' (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\">\\n          </ng-container>\\n        </div>\\n        <div class=\\\"x\\\" (click)=\\\"removeHistoryItem(idx, $event)\\\">\\n          <i class=\\\"material-icons\\\">close</i>\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\\n  <!--Not found-->\\n  <div class=\\\"not-found\\\" *ngIf=\\\"isLoading ? !isLoading && notFound : notFound\\\">\\n    <ng-container\\n      *ngTemplateOutlet=\\\"notFoundTemplate;  context: { $implicit: notFoundText  }\\\">\\n    </ng-container>\\n  </div>\\n</div>\\n<div class=\\\"overlay\\\" *ngIf=\\\"overlay\\\" (click)=\\\"handleOverlay()\\\"></div>\\n\",\n                    providers: [\n                        {\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return AutocompleteComponent; })),\n                            multi: true\n                        }\n                    ],\n                    encapsulation: ViewEncapsulation.None,\n                    host: {\n                        '(document:click)': 'handleClick($event)',\n                        'class': 'ng-autocomplete'\n                    },\n                    styles: [\"@import url(https://fonts.googleapis.com/icon?family=Material+Icons);.ng-autocomplete{width:600px}.autocomplete-container{box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);position:relative;overflow:visible;height:40px}.autocomplete-container .input-container input{font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:0;background-color:#fff;color:rgba(0,0,0,.87);width:100%;padding:0 15px;line-height:40px;height:40px}.autocomplete-container .input-container input:disabled{background-color:#eee;color:#666}.autocomplete-container .input-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .input-container .x i{color:rgba(0,0,0,.54);font-size:22px;vertical-align:middle}.autocomplete-container .suggestions-container{position:absolute;width:100%;background:#fff;height:auto;box-shadow:0 2px 5px rgba(0,0,0,.25);box-sizing:border-box}.autocomplete-container .suggestions-container ul{padding:0;margin:0;max-height:240px;overflow-y:auto}.autocomplete-container .suggestions-container ul li{position:relative;list-style:none;padding:0;margin:0;cursor:pointer}.autocomplete-container .suggestions-container ul li a{padding:14px 15px;display:block;text-decoration:none;cursor:pointer;color:rgba(0,0,0,.87);font-size:15px}.autocomplete-container .suggestions-container .complete-selected,.autocomplete-container .suggestions-container ul li:hover{background-color:rgba(158,158,158,.18)}.autocomplete-container .suggestions-container .heading{position:relative;padding:10px 15px;border:1px solid #f1f1f1}.autocomplete-container .suggestions-container .heading .text{font-size:.85em}.autocomplete-container .suggestions-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .suggestions-container .x i{color:rgba(0,0,0,.54);font-size:18px;vertical-align:middle}.autocomplete-container .suggestions-container.is-hidden{visibility:hidden}.autocomplete-container .suggestions-container.is-visible{visibility:visible}.autocomplete-container .not-found{padding:0 .75em;border:1px solid #f1f1f1;background:#fff}.autocomplete-container .not-found div{padding:.4em 0;font-size:.95em;line-height:1.4;border-bottom:1px solid rgba(230,230,230,.7)}.autocomplete-container.active{z-index:999}.highlight{font-weight:700}.overlay{position:absolute;background-color:transparent;width:100%;height:100%;top:0;right:0;bottom:0;left:0;z-index:50}input[type=text]::-ms-clear{display:none}.sk-fading-circle{width:20px;height:20px;position:absolute;right:10px;top:0;bottom:0;margin:auto}.sk-fading-circle .sk-circle{width:100%;height:100%;position:absolute;left:0;top:0}.sk-fading-circle .sk-circle:before{content:\\\"\\\";display:block;margin:0 auto;width:15%;height:15%;background-color:#333;border-radius:100%;-webkit-animation:1.2s ease-in-out infinite both sk-circleFadeDelay;animation:1.2s ease-in-out infinite both sk-circleFadeDelay}.sk-fading-circle .sk-circle2{-webkit-transform:rotate(30deg);transform:rotate(30deg)}.sk-fading-circle .sk-circle3{-webkit-transform:rotate(60deg);transform:rotate(60deg)}.sk-fading-circle .sk-circle4{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.sk-fading-circle .sk-circle5{-webkit-transform:rotate(120deg);transform:rotate(120deg)}.sk-fading-circle .sk-circle6{-webkit-transform:rotate(150deg);transform:rotate(150deg)}.sk-fading-circle .sk-circle7{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.sk-fading-circle .sk-circle8{-webkit-transform:rotate(210deg);transform:rotate(210deg)}.sk-fading-circle .sk-circle9{-webkit-transform:rotate(240deg);transform:rotate(240deg)}.sk-fading-circle .sk-circle10{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.sk-fading-circle .sk-circle11{-webkit-transform:rotate(300deg);transform:rotate(300deg)}.sk-fading-circle .sk-circle12{-webkit-transform:rotate(330deg);transform:rotate(330deg)}.sk-fading-circle .sk-circle2:before{-webkit-animation-delay:-1.1s;animation-delay:-1.1s}.sk-fading-circle .sk-circle3:before{-webkit-animation-delay:-1s;animation-delay:-1s}.sk-fading-circle .sk-circle4:before{-webkit-animation-delay:-.9s;animation-delay:-.9s}.sk-fading-circle .sk-circle5:before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.sk-fading-circle .sk-circle6:before{-webkit-animation-delay:-.7s;animation-delay:-.7s}.sk-fading-circle .sk-circle7:before{-webkit-animation-delay:-.6s;animation-delay:-.6s}.sk-fading-circle .sk-circle8:before{-webkit-animation-delay:-.5s;animation-delay:-.5s}.sk-fading-circle .sk-circle9:before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.sk-fading-circle .sk-circle10:before{-webkit-animation-delay:-.3s;animation-delay:-.3s}.sk-fading-circle .sk-circle11:before{-webkit-animation-delay:-.2s;animation-delay:-.2s}.sk-fading-circle .sk-circle12:before{-webkit-animation-delay:-.1s;animation-delay:-.1s}@-webkit-keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}@keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}\"]\n                }] }\n    ];\n    /** @nocollapse */\n    AutocompleteComponent.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Renderer2 }\n    ]; };\n    AutocompleteComponent.propDecorators = {\n        searchInput: [{ type: ViewChild, args: ['searchInput',] }],\n        filteredListElement: [{ type: ViewChild, args: ['filteredListElement',] }],\n        historyListElement: [{ type: ViewChild, args: ['historyListElement',] }],\n        data: [{ type: Input }],\n        searchKeyword: [{ type: Input }],\n        placeHolder: [{ type: Input }],\n        heading: [{ type: Input }],\n        initialValue: [{ type: Input }],\n        historyIdentifier: [{ type: Input }],\n        historyHeading: [{ type: Input }],\n        historyListMaxNumber: [{ type: Input }],\n        notFoundText: [{ type: Input }],\n        isLoading: [{ type: Input }],\n        debounceTime: [{ type: Input }],\n        disabled: [{ type: Input }],\n        minQueryLength: [{ type: Input }],\n        selected: [{ type: Output }],\n        inputChanged: [{ type: Output }],\n        inputFocused: [{ type: Output }],\n        inputCleared: [{ type: Output }],\n        opened: [{ type: Output }],\n        closed: [{ type: Output }],\n        scrolledToEnd: [{ type: Output }],\n        itemTemplate: [{ type: Input }],\n        notFoundTemplate: [{ type: Input }],\n        customTemplate: [{ type: ContentChild, args: [TemplateRef,] }]\n    };\n    return AutocompleteComponent;\n}());\nif (false) {\n    /** @type {?} */\n    AutocompleteComponent.prototype.searchInput;\n    /** @type {?} */\n    AutocompleteComponent.prototype.filteredListElement;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyListElement;\n    /** @type {?} */\n    AutocompleteComponent.prototype.inputKeyUp$;\n    /** @type {?} */\n    AutocompleteComponent.prototype.inputKeyDown$;\n    /** @type {?} */\n    AutocompleteComponent.prototype.query;\n    /** @type {?} */\n    AutocompleteComponent.prototype.filteredList;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyList;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isHistoryListVisible;\n    /** @type {?} */\n    AutocompleteComponent.prototype.elementRef;\n    /** @type {?} */\n    AutocompleteComponent.prototype.selectedIdx;\n    /** @type {?} */\n    AutocompleteComponent.prototype.toHighlight;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFound;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isFocused;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isOpen;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isScrollToEnd;\n    /** @type {?} */\n    AutocompleteComponent.prototype.overlay;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.manualOpen;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.manualClose;\n    /**\n     * Data of items list.\n     * It can be array of strings or array of objects.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.data;\n    /** @type {?} */\n    AutocompleteComponent.prototype.searchKeyword;\n    /** @type {?} */\n    AutocompleteComponent.prototype.placeHolder;\n    /** @type {?} */\n    AutocompleteComponent.prototype.heading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.initialValue;\n    /**\n     * History identifier of history list\n     * When valid history identifier is given, then component stores selected item to local storage of user's browser.\n     * If it is null then history is hidden.\n     * History list is visible if at least one history item is stored.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.historyIdentifier;\n    /**\n     * Heading text of history list.\n     * If it is null then history heading is hidden.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.historyHeading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyListMaxNumber;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFoundText;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isLoading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.debounceTime;\n    /** @type {?} */\n    AutocompleteComponent.prototype.disabled;\n    /**\n     * The minimum number of characters the user must type before a search is performed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.minQueryLength;\n    /**\n     * Event that is emitted whenever an item from the list is selected.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.selected;\n    /**\n     * Event that is emitted whenever an input is changed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputChanged;\n    /**\n     * Event that is emitted whenever an input is focused.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputFocused;\n    /**\n     * Event that is emitted whenever an input is cleared.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputCleared;\n    /**\n     * Event that is emitted when the autocomplete panel is opened.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.opened;\n    /**\n     * Event that is emitted when the autocomplete panel is closed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.closed;\n    /**\n     * Event that is emitted when scrolled to the end of items.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.scrolledToEnd;\n    /** @type {?} */\n    AutocompleteComponent.prototype.itemTemplate;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFoundTemplate;\n    /** @type {?} */\n    AutocompleteComponent.prototype.customTemplate;\n    /**\n     * Propagates new value when model changes\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.propagateChange;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.renderer;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/highlight.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar HighlightPipe = /** @class */ (function () {\n    function HighlightPipe() {\n    }\n    /**\n     * @param {?} text\n     * @param {?} search\n     * @param {?=} searchKeyword\n     * @return {?}\n     */\n    HighlightPipe.prototype.transform = /**\n     * @param {?} text\n     * @param {?} search\n     * @param {?=} searchKeyword\n     * @return {?}\n     */\n    function (text, search, searchKeyword) {\n        /** @type {?} */\n        var pattern = search.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n        pattern = pattern.split(' ').filter((/**\n         * @param {?} t\n         * @return {?}\n         */\n        function (t) {\n            return t.length > 0;\n        })).join('|');\n        /** @type {?} */\n        var regex = new RegExp(pattern, 'gi');\n        if (!search) {\n            return text;\n        }\n        if (searchKeyword) {\n            /** @type {?} */\n            var name_1 = text[searchKeyword].replace(regex, (/**\n             * @param {?} match\n             * @return {?}\n             */\n            function (match) { return \"<b>\" + match + \"</b>\"; }));\n            // copy original object\n            /** @type {?} */\n            var text2 = __assign({}, text);\n            // set bold value into searchKeyword of copied object\n            text2[searchKeyword] = name_1;\n            return text2;\n        }\n        else {\n            return search ? text.replace(regex, (/**\n             * @param {?} match\n             * @return {?}\n             */\n            function (match) { return \"<b>\" + match + \"</b>\"; })) : text;\n        }\n    };\n    HighlightPipe.decorators = [\n        { type: Pipe, args: [{\n                    name: 'highlight'\n                },] }\n    ];\n    return HighlightPipe;\n}());\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AutocompleteLibModule = /** @class */ (function () {\n    function AutocompleteLibModule() {\n    }\n    AutocompleteLibModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule\n                    ],\n                    declarations: [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe],\n                    exports: [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe]\n                },] }\n    ];\n    return AutocompleteLibModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-ng-autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AutocompleteComponent, AutocompleteLibComponent, AutocompleteLibModule, HighlightPipe };\n"]}